<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="如欲采蜜，勿蹴蜂房">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="如欲采蜜，勿蹴蜂房">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jiaxin Fang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiaxin Fang"
      src="/images/OIP.jpg">
  <p class="site-author-name" itemprop="name">Jiaxin Fang</p>
  <div class="site-description" itemprop="description">如欲采蜜，勿蹴蜂房</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/OIP.jpg">
      <meta itemprop="name" content="Jiaxin Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="如欲采蜜，勿蹴蜂房">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/07/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-07 19:59:06" itemprop="dateCreated datePublished" datetime="2022-04-07T19:59:06+08:00">2022-04-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/xv6-system-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/OIP.jpg">
      <meta itemprop="name" content="Jiaxin Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="如欲采蜜，勿蹴蜂房">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/07/xv6-system-call/" class="post-title-link" itemprop="url">xv6 system call</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-07 18:49:42" itemprop="dateCreated datePublished" datetime="2022-04-07T18:49:42+08:00">2022-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-13 19:53:17" itemprop="dateModified" datetime="2022-04-13T19:53:17+08:00">2022-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="1-源码分析："><a href="#1-源码分析：" class="headerlink" title="1.源码分析："></a>1.源码分析：</h2><p>用户空间</p>

<h4 id="user-x2F-user-h"><a href="#user-x2F-user-h" class="headerlink" title="user&#x2F;user.h"></a>user&#x2F;user.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user.h文件中声明用户空间发起系统调用函数  以open系统调用为例</span></span><br><span class="line"><span class="comment">//第一个参数是文件路径，第二个参数是打开模式 此函数由用户调用，作为进入内核的接口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="user-x2F-usys-pl"><a href="#user-x2F-usys-pl" class="headerlink" title="user&#x2F;usys.pl"></a>user&#x2F;usys.pl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usys.pl 声明用户系统调用的存根，这里是用户态真正切换至内核态的接口，通过entry实现，同样以open为例（entry具体实现将在lab4中学习）</span></span><br><span class="line">#!/usr/bin/perl -w	</span><br><span class="line"># Generate usys.S, the stubs <span class="keyword">for</span> syscalls.</span><br><span class="line">print <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line">print <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	sub entry &#123;</span><br><span class="line">   	    my $name = shift;</span><br><span class="line">   	    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">        print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    	print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    	print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">   	    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">   entry(<span class="string">&quot;open&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>usys.pl文件经过Makefile编译后会生成usys.S如下:<p>

<pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open:</span><br><span class="line"> li a7, SYS_open</span><br><span class="line">  ecall</span><br><span class="line">  ret</span><br><span class="line">  .global mknod</span><br></pre></td></tr></table></figure>
</code></pre>
<p> 我们可以看到usys.S其实是一个汇编语言文件，系统调用号SYS_open存在了a7寄存器中，调用echall进入内核态（用户态进入内核态的具体实现会在lab4中实现）</p>

<p>内核空间</p>
<h4 id="kernel-x2F-syscall-h"><a href="#kernel-x2F-syscall-h" class="headerlink" title="kernel&#x2F;syscall.h"></a>kernel&#x2F;syscall.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里声明了系统调用号常量，SYS_open就等于15</p>

<h4 id="kernel-x2F-sysfile-c"><a href="#kernel-x2F-sysfile-c" class="headerlink" title="kernel&#x2F;sysfile.c"></a>kernel&#x2F;sysfile.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sys_open函数实现了open系统调用的顶层实现      </span></span><br><span class="line">      uint64</span><br><span class="line">   <span class="number">287</span> 	sys_open(<span class="type">void</span>)</span><br><span class="line">   <span class="number">288</span>	&#123;</span><br><span class="line">   <span class="number">289</span>	  <span class="type">char</span> path[MAXPATH];  <span class="comment">//从用户空间取路径并存储</span></span><br><span class="line">   <span class="number">290</span>	  <span class="type">int</span> fd, omode;       <span class="comment">//定义文件描述符，和文件模式</span></span><br><span class="line">   <span class="number">291</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span>     <span class="comment">//文件结构体 在file.c中有声明</span></span><br><span class="line">   <span class="number">292</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>   <span class="comment">//文件inode索引，通过inode可以查找到文件在磁盘上的位置</span></span><br><span class="line">   <span class="number">293</span>	  <span class="type">int</span> n;              </span><br><span class="line">   <span class="number">294</span>	</span><br><span class="line">   <span class="number">295</span>	  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)  <span class="comment">//需要将数据从用户空间转移到内核空间 copyinstr(p-&gt;pagetable, buf, addr, max)  argstr具体实现细节在syscall.c中，下方附上了代码 第一个参数是路径，第二个参数是文件模式，分别存在寄存器a0,a1中</span></span><br><span class="line">   <span class="number">296</span>	    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//拷贝路径及参数</span></span><br><span class="line">   <span class="number">297</span>	</span><br><span class="line">           <span class="comment">//权限检查</span></span><br><span class="line">   <span class="number">298</span>	  begin_op();</span><br><span class="line">   <span class="number">299</span>	</span><br><span class="line">   <span class="number">300</span>	  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">   <span class="number">301</span>	    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//创建inode</span></span><br><span class="line">   <span class="number">302</span>	    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="number">303</span>	      end_op();</span><br><span class="line">   <span class="number">304</span>	      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="number">305</span>	    &#125;</span><br><span class="line">   <span class="number">306</span>	  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">   <span class="number">307</span>	    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;    <span class="comment">//根据路径查找文件对应的inode编号，inode编号可以让我们在磁盘中查找文件所在的扇区</span></span><br><span class="line">   <span class="number">308</span>	      end_op();</span><br><span class="line">   <span class="number">309</span>	      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="number">310</span>	    &#125;</span><br><span class="line">   <span class="number">311</span>	    ilock(ip);</span><br><span class="line">   <span class="number">312</span>	    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">   <span class="number">313</span>	      iunlockput(ip);</span><br><span class="line">   <span class="number">314</span>	      end_op();</span><br><span class="line">   <span class="number">315</span>	      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="number">316</span>	    &#125;</span><br><span class="line">   <span class="number">317</span>	  &#125;</span><br><span class="line">   <span class="number">318</span>	</span><br><span class="line">   <span class="number">319</span>	  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">   <span class="number">320</span>	    iunlockput(ip);</span><br><span class="line">   <span class="number">321</span>	    end_op();</span><br><span class="line">   <span class="number">322</span>	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="number">323</span>	  &#125;</span><br><span class="line">   <span class="number">324</span>	</span><br><span class="line">   <span class="number">325</span>	  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123; <span class="comment">//生成文件描述符   filealloc函数在file.c中定义，下面给出具体实现</span></span><br><span class="line">   <span class="number">326</span>	    <span class="keyword">if</span>(f)</span><br><span class="line">   <span class="number">327</span>	      fileclose(f);</span><br><span class="line">   <span class="number">328</span>	    iunlockput(ip);</span><br><span class="line">   <span class="number">329</span>	    end_op();</span><br><span class="line">   <span class="number">330</span>	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="number">331</span>	  &#125;</span><br><span class="line">   <span class="number">332</span>	</span><br><span class="line">   <span class="number">333</span>	  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">   <span class="number">334</span>	    f-&gt;type = FD_DEVICE;</span><br><span class="line">   <span class="number">335</span>	    f-&gt;major = ip-&gt;major;</span><br><span class="line">   <span class="number">336</span>	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="number">337</span>	    f-&gt;type = FD_INODE;</span><br><span class="line">   <span class="number">338</span>	    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">   <span class="number">339</span>	  &#125;      </span><br><span class="line">   <span class="number">340</span>	  f-&gt;ip = ip;   <span class="comment">//赋值inode索引</span></span><br><span class="line">   <span class="number">341</span>	  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">   <span class="number">342</span>	  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line">   <span class="number">343</span>	</span><br><span class="line">   <span class="number">344</span>	  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">   <span class="number">345</span>	    itrunc(ip);</span><br><span class="line">   <span class="number">346</span>	  &#125;</span><br><span class="line">   <span class="number">347</span>	</span><br><span class="line">   <span class="number">348</span>	  iunlock(ip);</span><br><span class="line">   <span class="number">349</span>	  end_op();</span><br><span class="line">   <span class="number">350</span>	</span><br><span class="line">   <span class="number">351</span>	  <span class="keyword">return</span> fd; <span class="comment">//返回文件描述符</span></span><br><span class="line">   <span class="number">352</span>	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>  <span class="comment">// Fetch the nth word-sized system call argument as a file descriptor</span></span><br><span class="line"><span class="number">20</span> <span class="comment">// and return both the descriptor and the corresponding struct file.</span></span><br><span class="line"><span class="number">21</span> <span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="number">22</span> argfd(<span class="type">int</span> n, <span class="type">int</span> *pfd, <span class="keyword">struct</span> file **pf)  <span class="comment">//argfd(0, 0, &amp;f) &lt; 0   读取寄存器0当中的文件描述符 如果描述符合法，那么将描述符地址与文件结构地址返回</span></span><br><span class="line"><span class="number">23</span> &#123;</span><br><span class="line"><span class="number">24</span>   <span class="type">int</span> fd;</span><br><span class="line"><span class="number">25</span>   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>   <span class="keyword">if</span>(argint(n, &amp;fd) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">29</span>   <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == <span class="number">0</span>)</span><br><span class="line"><span class="number">30</span>     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">31</span>   <span class="keyword">if</span>(pfd)</span><br><span class="line"><span class="number">32</span>     *pfd = fd;</span><br><span class="line"><span class="number">33</span>   <span class="keyword">if</span>(pf)</span><br><span class="line"><span class="number">34</span>     *pf = f; </span><br><span class="line"><span class="number">35</span>   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">36</span> &#125;</span><br><span class="line"><span class="number">37</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span>  <span class="comment">// Allocate a file descriptor for the given file.</span></span><br><span class="line"><span class="number">39</span> <span class="comment">// Takes over file reference from caller on success.</span></span><br><span class="line"><span class="number">40</span> <span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="number">41</span> fdalloc(<span class="keyword">struct</span> file *f) <span class="comment">//产生文件描述符</span></span><br><span class="line"><span class="number">42</span> &#123;</span><br><span class="line"><span class="number">43</span>   <span class="type">int</span> fd;   </span><br><span class="line"><span class="number">44</span>   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  <span class="comment">//获取当前进程结构</span></span><br><span class="line"><span class="number">45</span> </span><br><span class="line"><span class="number">46</span>   <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;  <span class="comment">//ofile数组索引为文件描述符，元素为对应的文件结构</span></span><br><span class="line"><span class="number">47</span>     <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">48</span>       p-&gt;ofile[fd] = f;</span><br><span class="line"><span class="number">49</span>       <span class="keyword">return</span> fd; <span class="comment">//返回文件描述符 可以根据文件描述符到进程结构中找到相应的文件结构</span></span><br><span class="line"><span class="number">50</span>     &#125;</span><br><span class="line"><span class="number">51</span>   &#125;</span><br><span class="line"><span class="number">52</span>   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">53</span> &#125;</span><br><span class="line"><span class="number">54</span> </span><br></pre></td></tr></table></figure>

<p>下面一步步解释sys_open中实现了什么！</p>

<p> 1. 首先先从寄存器a0中读出打开文件的路径，从寄存器a1中读出文件模式（只读或读写），并将路径存储在path中,argstr函数返回路径字符串长度</p>

<p>2.检查权限，查看是否是打开并创建的模式，如果是那么创建inode，如果已经存在该文件那么根据路径查找文件对应的inode编号，inode编号可以让我们在磁盘中查找文件所在的扇区。</p>   
**下面的判断还不清楚，待学习 ** 

  <p> fdalloc函数生成文件描述符，filealloc返回一个文件结构体指针。将我们文件结构体指针f链接到当前进程的ofile数组中，其中数组的索引为文件描述符，元素为指向逻辑文件结构体的指针，之后我们再对这个文件结构体指针赋值，将f->ip赋值为我们的inode索引，对文件状态赋值，返回文件描述符。

<h4 id="kernel-x2F-syscall-c"><a href="#kernel-x2F-syscall-c" class="headerlink" title="kernel&#x2F;syscall.c"></a>kernel&#x2F;syscall.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line">     <span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line">     <span class="number">3</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line">     <span class="number">4</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line">     <span class="number">5</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line">     <span class="number">6</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line">     <span class="number">7</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line">     <span class="number">8</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line">     <span class="number">9</span>	</span><br><span class="line">    <span class="number">10</span>	<span class="comment">// Fetch the uint64 at addr from the current process.</span></span><br><span class="line">    <span class="number">11</span>	<span class="type">int</span></span><br><span class="line">    <span class="number">12</span>	fetchaddr(uint64 addr, uint64 *ip)</span><br><span class="line">    <span class="number">13</span>	&#123;</span><br><span class="line">    <span class="number">14</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="number">15</span>	  <span class="keyword">if</span>(addr &gt;= p-&gt;sz || addr+<span class="keyword">sizeof</span>(uint64) &gt; p-&gt;sz)</span><br><span class="line">    <span class="number">16</span>	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="number">17</span>	  <span class="keyword">if</span>(copyin(p-&gt;pagetable, (<span class="type">char</span> *)ip, addr, <span class="keyword">sizeof</span>(*ip)) != <span class="number">0</span>)</span><br><span class="line">    <span class="number">18</span>	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="number">19</span>	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">20</span>	&#125;</span><br><span class="line">    <span class="number">21</span>	</span><br><span class="line">    <span class="number">22</span>	<span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line">    <span class="number">23</span>	<span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line">    <span class="number">24</span>	<span class="type">int</span></span><br><span class="line">    <span class="number">25</span>	fetchstr(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span><br><span class="line">    <span class="number">26</span>	&#123;</span><br><span class="line">    <span class="number">27</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="number">28</span>	  <span class="type">int</span> err = copyinstr(p-&gt;pagetable, buf, addr, max);<span class="comment">//将addr中的内容读到buf中，将用户空间内容复制到内核空间中</span></span><br><span class="line">    <span class="number">29</span>	  <span class="keyword">if</span>(err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="number">30</span>	    <span class="keyword">return</span> err;</span><br><span class="line">    <span class="number">31</span>	  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf); <span class="comment">//返回字符串长度</span></span><br><span class="line">    <span class="number">32</span>	&#125;</span><br><span class="line">    <span class="number">33</span>	</span><br><span class="line">    <span class="number">34</span>	<span class="type">static</span> uint64</span><br><span class="line">    <span class="number">35</span>	argraw(<span class="type">int</span> n)</span><br><span class="line">    <span class="number">36</span>	&#123;</span><br><span class="line">    <span class="number">37</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  <span class="comment">//获取当前进程</span></span><br><span class="line">    <span class="number">38</span>	  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="number">39</span>	  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="number">40</span>	    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0; <span class="comment">//返回进程对应寄存器的值</span></span><br><span class="line">    <span class="number">41</span>	  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="number">42</span>	    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">    <span class="number">43</span>	  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="number">44</span>	    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">    <span class="number">45</span>	  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="number">46</span>	    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">    <span class="number">47</span>	  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="number">48</span>	    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">    <span class="number">49</span>	  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="number">50</span>	    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">    <span class="number">51</span>	  &#125;</span><br><span class="line">    <span class="number">52</span>	  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">    <span class="number">53</span>	  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="number">54</span>	&#125;</span><br><span class="line">    <span class="number">55</span>	</span><br><span class="line">    <span class="number">56</span>	<span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line">    <span class="number">57</span>	<span class="type">int</span></span><br><span class="line">    <span class="number">58</span>	argint(<span class="type">int</span> n, <span class="type">int</span> *ip)</span><br><span class="line">    <span class="number">59</span>	&#123;</span><br><span class="line">    <span class="number">60</span>	  *ip = argraw(n);</span><br><span class="line">    <span class="number">61</span>	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">62</span>	&#125;</span><br><span class="line">    <span class="number">63</span>	</span><br><span class="line">    <span class="number">64</span>	<span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line">    <span class="number">65</span>	<span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line">    <span class="number">66</span>	<span class="comment">// copyin/copyout will do that.</span></span><br><span class="line">    <span class="number">67</span>	<span class="type">int</span></span><br><span class="line">    <span class="number">68</span>	argaddr(<span class="type">int</span> n, uint64 *ip)</span><br><span class="line">    <span class="number">69</span>	&#123;</span><br><span class="line">    <span class="number">70</span>	  *ip = argraw(n);  <span class="comment">//argraw函数为根据n的值寻找相应的寄存器中的值</span></span><br><span class="line">    <span class="number">71</span>	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">72</span>	&#125;</span><br><span class="line">    <span class="number">73</span>	</span><br><span class="line">    <span class="number">74</span>	<span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line">    <span class="number">75</span>	<span class="comment">// Copies into buf, at most max.</span></span><br><span class="line">    <span class="number">76</span>	<span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line">    <span class="number">77</span>	<span class="type">int</span></span><br><span class="line">    <span class="number">78</span>	argstr(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)  <span class="comment">//n:寄存器索引 buf:读的内容存储在buf中 max:最大容量</span></span><br><span class="line">    <span class="number">79</span>	&#123;</span><br><span class="line">    <span class="number">80</span>	  uint64 addr;</span><br><span class="line">    <span class="number">81</span>	  <span class="keyword">if</span>(argaddr(n, &amp;addr) &lt; <span class="number">0</span>)  <span class="comment">//将寄存器a0的内容读到addr中</span></span><br><span class="line">    <span class="number">82</span>	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="number">83</span>	  <span class="keyword">return</span> fetchstr(addr, buf, max); <span class="comment">//将addr中的内容写入buf中</span></span><br><span class="line">    <span class="number">84</span>	&#125;</span><br><span class="line">    <span class="number">85</span>	</span><br><span class="line">    <span class="number">86</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">87</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">88</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">89</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">90</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">91</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">92</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">93</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">94</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">95</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">96</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">97</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">98</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="number">99</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">100</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">101</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">102</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">103</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">104</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">105</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">106</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">107</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">108</span>	<span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="number">109</span>	</span><br><span class="line">   <span class="number">110</span>	<span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">   <span class="number">111</span>	[SYS_fork]    sys_fork,</span><br><span class="line">   <span class="number">112</span>	[SYS_exit]    sys_exit,</span><br><span class="line">   <span class="number">113</span>	[SYS_wait]    sys_wait,</span><br><span class="line">   <span class="number">114</span>	[SYS_pipe]    sys_pipe,</span><br><span class="line">   <span class="number">115</span>	[SYS_read]    sys_read,</span><br><span class="line">   <span class="number">116</span>	[SYS_kill]    sys_kill,</span><br><span class="line">   <span class="number">117</span>	[SYS_exec]    sys_exec,</span><br><span class="line">   <span class="number">118</span>	[SYS_fstat]   sys_fstat,</span><br><span class="line">   <span class="number">119</span>	[SYS_chdir]   sys_chdir,</span><br><span class="line">   <span class="number">120</span>	[SYS_dup]     sys_dup,</span><br><span class="line">   <span class="number">121</span>	[SYS_getpid]  sys_getpid,</span><br><span class="line">   <span class="number">122</span>	[SYS_sbrk]    sys_sbrk,</span><br><span class="line">   <span class="number">123</span>	[SYS_sleep]   sys_sleep,</span><br><span class="line">   <span class="number">124</span>	[SYS_uptime]  sys_uptime,</span><br><span class="line">   <span class="number">125</span>	[SYS_open]    sys_open,</span><br><span class="line">   <span class="number">126</span>	[SYS_write]   sys_write,</span><br><span class="line">   <span class="number">127</span>	[SYS_mknod]   sys_mknod,</span><br><span class="line">   <span class="number">128</span>	[SYS_unlink]  sys_unlink,</span><br><span class="line">   <span class="number">129</span>	[SYS_link]    sys_link,</span><br><span class="line">   <span class="number">130</span>	[SYS_mkdir]   sys_mkdir,</span><br><span class="line">   <span class="number">131</span>	[SYS_close]   sys_close,</span><br><span class="line">   <span class="number">132</span>	[SYS_trace]   sys_trace,</span><br><span class="line">   <span class="number">133</span>	[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">   <span class="number">134</span>	&#125;;</span><br><span class="line">   <span class="number">135</span>	<span class="type">char</span>* sys_name[<span class="number">23</span>]=&#123;</span><br><span class="line">   <span class="number">136</span>	  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">   <span class="number">137</span>	  <span class="string">&quot;syscall fork&quot;</span>,</span><br><span class="line">   <span class="number">138</span>	  <span class="string">&quot;syscall exit&quot;</span>,</span><br><span class="line">   <span class="number">139</span>	  <span class="string">&quot;syscall wait&quot;</span>,</span><br><span class="line">   <span class="number">140</span>	  <span class="string">&quot;syscall pipe&quot;</span>,</span><br><span class="line">   <span class="number">141</span>	  <span class="string">&quot;syscall read&quot;</span>,</span><br><span class="line">   <span class="number">142</span>	  <span class="string">&quot;syscall kill&quot;</span>,</span><br><span class="line">   <span class="number">143</span>	  <span class="string">&quot;syscall exec&quot;</span>,</span><br><span class="line">   <span class="number">144</span>	  <span class="string">&quot;syscall fstat&quot;</span>,</span><br><span class="line">   <span class="number">145</span>	  <span class="string">&quot;syscall chdir&quot;</span>,</span><br><span class="line">   <span class="number">146</span>	  <span class="string">&quot;syscall dup&quot;</span>,</span><br><span class="line">   <span class="number">147</span>	  <span class="string">&quot;syscall getpid&quot;</span>,</span><br><span class="line">   <span class="number">148</span>	  <span class="string">&quot;syscall sbrk&quot;</span>,</span><br><span class="line">   <span class="number">149</span>	  <span class="string">&quot;syscall sleep&quot;</span>,</span><br><span class="line">   <span class="number">150</span>	  <span class="string">&quot;syscall uptime&quot;</span>,</span><br><span class="line">   <span class="number">151</span>	  <span class="string">&quot;syscall open&quot;</span>,</span><br><span class="line">   <span class="number">152</span>	  <span class="string">&quot;syscall write&quot;</span>,</span><br><span class="line">   <span class="number">153</span>	  <span class="string">&quot;syscall mknod&quot;</span>,</span><br><span class="line">   <span class="number">154</span>	  <span class="string">&quot;syscall unlink&quot;</span>,</span><br><span class="line">   <span class="number">155</span>	  <span class="string">&quot;syscall link&quot;</span>,</span><br><span class="line">   <span class="number">156</span>	  <span class="string">&quot;syscall mkdir&quot;</span>,</span><br><span class="line">   <span class="number">157</span>	  <span class="string">&quot;syscall close&quot;</span>,</span><br><span class="line">   <span class="number">158</span>	  <span class="string">&quot;syscall trace&quot;</span>,</span><br><span class="line">   <span class="number">159</span>	</span><br><span class="line">   <span class="number">160</span>	</span><br><span class="line">   <span class="number">161</span>	&#125;;</span><br><span class="line">   <span class="number">162</span>	<span class="type">void</span></span><br><span class="line">   <span class="number">163</span>	syscall(<span class="type">void</span>)</span><br><span class="line">   <span class="number">164</span>	&#123;</span><br><span class="line">   <span class="number">165</span>	  <span class="type">int</span> num;</span><br><span class="line">   <span class="number">166</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">   <span class="number">167</span>	</span><br><span class="line">   <span class="number">168</span>	  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">   <span class="number">169</span>	  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">   <span class="number">170</span>	    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">   <span class="number">171</span>	    <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;num)&amp;p-&gt;mask)</span><br><span class="line">   <span class="number">172</span>	    &#123;  <span class="built_in">printf</span>(<span class="string">&quot;%d: %s -&gt; %d\n&quot;</span>,p-&gt;pid,sys_name[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">   <span class="number">173</span>	    &#125;</span><br><span class="line">   <span class="number">174</span>	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="number">175</span>	    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">   <span class="number">176</span>	            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">   <span class="number">177</span>	    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">   <span class="number">178</span>	  &#125;</span><br><span class="line">   <span class="number">179</span>	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在sys_open中返回的文件描述符被赋值到a0寄存器中，这里syscall函数可以理解为内核的总的系统调用，实现过程如下：

<p>首先从a7寄存器中取得系统调用号，然后通过系统调用号去索引syscalls这个函数指针数组，syscalls的意思是数组中每一个元素都是指向函数的指针，存储的是函数的首地址， 我们有syscall.h可以知道，open的系统调用号是15，对应syscalls中的sys_open,由此知道syscalls[num]()就相当于调用sys_open函数，这里使用extern引入了我们在其他文件中定义的sys_open实现，返回的文件描述符送入a0寄存器中。</p>

<h4 id="kernel-x2F-file-c"><a href="#kernel-x2F-file-c" class="headerlink" title="kernel&#x2F;file.c"></a>kernel&#x2F;file.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>	<span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class">30	<span class="title">filealloc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">31	&#123;</span></span><br><span class="line"><span class="number">32</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span>   <span class="comment">//声明file结构体</span></span><br><span class="line"><span class="number">33</span>	</span><br><span class="line"><span class="number">34</span>	  acquire(&amp;ftable.lock);</span><br><span class="line"><span class="number">35</span>	  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line"><span class="number">36</span>	    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;  </span><br><span class="line"><span class="number">37</span>	      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line"><span class="number">38</span>	      release(&amp;ftable.lock);</span><br><span class="line"><span class="number">39</span>	      <span class="keyword">return</span> f;</span><br><span class="line"><span class="number">40</span>	    &#125;</span><br><span class="line"><span class="number">41</span>	  &#125;</span><br><span class="line"><span class="number">42</span>	  release(&amp;ftable.lock);</span><br><span class="line"><span class="number">43</span>	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">44</span>	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实验1分析"><a href="#2-实验1分析" class="headerlink" title="2.实验1分析"></a>2.实验1分析</h3><h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p> 实验描述如下:</p>

<p> 我们需要创建trace系统调用来追踪系统调用的过程 。</p>

<p>例如追踪fork系统调用: trace (1《SYS_fork),《为左移符号，SYS_fork是系统调用号。这个我们可以在之前的syscall.h文件中找到，我们需要去修改xv6的内核程序，使得trace追踪的系统调用返回时，能够打印一些提示信息，trace需要追踪的系统调用号存放在mask掩码中。打印出来的提示信息需要包括进程id号，系统调用名以及返回值，我们并不需要打印系统调用的参数，最后trace系统调用还需要能够追踪目标进程的子进程，并且不影响其他进程。 </p>

<p>我们提供了用户空间的trace.c文件</p>

<img src="/images/pictures/systemcall/lab1.PNG" alt="lab1" style="zoom: 67%;" />

<p>下面进入分析环节</p>

<h5 id="user-x2F-trace-c"><a href="#user-x2F-trace-c" class="headerlink" title="user&#x2F;trace.c"></a>user&#x2F;trace.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> *nargv[MAXARG];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || (argv[<span class="number">1</span>][<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || argv[<span class="number">1</span>][<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trace(atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class="line">    nargv[i<span class="number">-2</span>] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  exec(nargv[<span class="number">0</span>], nargv);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 

<p> 首先判断掩码是否符合要求，如果符合要求就传到trace函数中（准备trace系统调用入口），接着判断trace返回值，我们由之前的源码分析知道，内核中trace的返回值其实应该存放在a0寄存器中，可以查看上面的syscall.c文件。如果trace返回值为0，表明无错误，其实在trace的过程就是在内核中设置mask的过程，需要在内核中将mask保存，这样之后我们再进行系统调用，如果调用号与掩码中吻合，就打印追踪信息。这里通过exec执行后面的系统调用。</p>

<p> 当然用户空间上的操作还没有结束，我们仅仅设置了trace.c文件，需要在Makefile文件中加上$U/_trace
    </p>

<p>这样才能使得Makefile能够编译trace.c文件，同时需要在user.h文件中声明我们的trace函数，在usys.pl文件中加上存根，这样才能生成完整的usys.S汇编文件，将系统调用号存到a7寄存器中，通过ecall进入内核，具体实现如下：</p>
<h5 id="user-h"><a href="#user-h" class="headerlink" title="user.h"></a>user.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="usys-pl"><a href="#usys-pl" class="headerlink" title="usys.pl"></a>usys.pl</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/perl -w</span><br><span class="line"></span><br><span class="line"># Generate usys.S, the stubs <span class="keyword">for</span> syscalls.</span><br><span class="line"></span><br><span class="line">print <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">print <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 至此用户空间的操作已经结束，但是make qemu之后会失败,因为我们还需要在内核中去具体实现trace系统调用</p>

<h5 id="syscall-h"><a href="#syscall-h" class="headerlink" title="syscall.h"></a>syscall.h</h5><p>在syscall.h中需要加上trace的系统调用号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h5><p>我们需要在proc.h中的进程结构体中加入mask属性，来保存从a0寄存器中取得的掩码。进行trace系统调用其实就是保存掩码的过程，根据保存的掩码来判断后续系统调用是否需要跟踪</p></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="type">int</span> mask;<span class="comment">//system call mask number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h5><p>在sysproc.c文件中我们具体来实现trace系统调用，我们可以看到在用户空间中trace系统调用只有一个参数，那就是掩码，而这个参数是默认存储在a0寄存器中，所以我们从a0寄存器中取出mask,并保存到进程结构的mask属性中，只要进程不重新创建，我们的mask值就不会遗失</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mask;</span><br><span class="line">	<span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	myproc()-&gt;mask=mask;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>argint</code>函数其实是从a0寄存器中获取掩码的过程，掩码存放在mask中，调用<code>argraw</code>函数,这些函数是在syscall.c中声明，前面也有提到过。可以理解为syscall.c中封装了很多我们需要用到的函数的具体实现，在sysproc中去使用。<code>myproc</code>函数其实是在defs.h文件中被声明，defs.h文件中存储了非常多需要用到的函数的声明,<code>myproc</code>具体实现在proc.c文件中。</p>
<h5 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h5><p>在syscall.c文件中我们需要拿到进程的系统调用号，用掩码与系统调用号相对比，确认是否是需要我们跟踪的系统调用，如果是的话，就打印提示信息。同时我们还要提供一个可以得到系统调用名的字符串数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* sys_name[<span class="number">23</span>]=&#123;</span><br><span class="line">  <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall fork&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall exit&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall wait&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall pipe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall kill&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall exec&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall fstat&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall chdir&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall dup&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall getpid&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall sbrk&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall sleep&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall uptime&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall open&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall write&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall mknod&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall unlink&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall link&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall mkdir&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall close&quot;</span>,</span><br><span class="line">  <span class="string">&quot;syscall trace&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;num)&amp;p-&gt;mask)</span><br><span class="line">    &#123;  <span class="built_in">printf</span>(<span class="string">&quot;%d: %s -&gt; %d\n&quot;</span>,p-&gt;pid,sys_name[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h5><p>另外实验中还提示了，我们还需要对目标进程的子进程进行跟踪，也就是调用fork的时候，我们要修改fork系统调用的内核，使得新进程的mask属性等于原先进程的mask属性，才能调用fork之后仍能跟踪。</p>
<p>下面是fork实现源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  np-&gt;mask=p-&gt;mask;</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用allocproc生成一个进程结构体指针，设置新的进程参数，如果父进程存在文件描述符的队列，那么子进程也会共享这些文件描述符，返回生成的进程pid,具体细节之后再学习！</p>

<p>至此，内核部分的实现就大功告成了，可以使用make qemu执行了！</p>
<p>lab1的重点在于掌握内核实现的初步细节，比如如何读取用户空间的数据值，我们这里使用了通过读取ao寄存器的值来得到数据，并且将内核执行的结果放到a0寄存器来返回给用户空间 ，还有就是内核如何保存数据，如果之后的系统调用还需要用到这个数据，可以保存到进程结构体中。当然这是在该系统调用没有创建新的进程的情况下，从本次实验我还发现，能够创建新进程的系统调用少之又少，就算是exec系统调用，也是不会生成新的进程，只是将进程中的部分数据修改而已。而fork系统调用就会生成新的进程，它是如此的特殊，需要我们慢慢琢磨！  </p>

<p><u> 掌握的关键点如下：</u></p>
<p><b> 1. 内核初步实现细节   如何从用户空间获取数据，如何从内核将数据返回（使用寄存器）</b></p>
<p><b>2.内核如何保存数据，使得不同的系统调用可以用到这个数据 （使用进程结构体）</b></p>
<p>注意：上传图片的时候，使用/作为目录符号，使用\会失效</p>

<h3 id="3-实验2分析："><a href="#3-实验2分析：" class="headerlink" title="3.实验2分析："></a>3.实验2分析：</h3><h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>实验描述如下：</p>

<p>在实验2中我们需要增加一个sysinfo系统调用负责收集运行系统时的信息，这个系统调用携带一个参数，一个指向struct sysinfo结构体的指针，可以在kernel/sysinfo.h中看到。内核需要填写里面的信息,freemem属性是记录空内存的字节数，nproc属性是负责记录处于not UNUSED状态的进程数。同时我们提供了sysinfotest测试程序，在kernel/kalloc.c文件中书写一个函数获取当前空闲内存字节数，在kernel/proc.c文件中增加一个函数获取当前处于使用状态的进程数，参考kernel/file.c文件中的filestat函数与kernel/sysfile.c中的sys_fstat函数来学习如何将内核中的struct sysinfo变量复制并返回到用户空间</p>

<h5 id="sysinfotest-c"><a href="#sysinfotest-c" class="headerlink" title="sysinfotest.c"></a>sysinfotest.c</h5><p>下面具体分析sysinfotest.c中到底干了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sysinfo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *info)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sysinfo(info) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: sysinfo failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// use sbrk() to count how many free physical memory pages there are.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">countfree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sz0 = (uint64)sbrk(<span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((uint64)sbrk(PGSIZE) == <span class="number">0xffffffffffffffff</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">  <span class="keyword">if</span> (info.freemem != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: there is no free mem, but sysinfo.freemem=%d\n&quot;</span>,</span><br><span class="line">      info.freemem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sbrk(-((uint64)sbrk(<span class="number">0</span>) - sz0));</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">testmem</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 n = countfree();</span><br><span class="line">  </span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (info.freemem!= n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, info.freemem, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((uint64)<span class="keyword">struct</span> sysinfo(PGSIZE) == <span class="number">0xffffffffffffffff</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sbrk failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (info.freemem != n-PGSIZE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, n-PGSIZE, info.freemem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((uint64)sbrk(-PGSIZE) == <span class="number">0xffffffffffffffff</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sbrk failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (info.freemem != n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, n, info.freemem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">testcall</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sysinfo(&amp;info) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: sysinfo failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysinfo((<span class="keyword">struct</span> sysinfo *) <span class="number">0xeaeb0b5b00002f5e</span>) !=  <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: sysinfo succeeded with bad argument\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testproc</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 nproc;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  </span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">  nproc = info.nproc;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: fork failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    sinfo(&amp;info);</span><br><span class="line">    <span class="keyword">if</span>(info.nproc != nproc+<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: FAIL nproc is %d instead of %d\n&quot;</span>, info.nproc, nproc+<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">  <span class="keyword">if</span>(info.nproc != nproc) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: FAIL nproc is %d instead of %d\n&quot;</span>, info.nproc, nproc);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: start\n&quot;</span>);</span><br><span class="line">  testcall();</span><br><span class="line">  testmem();</span><br><span class="line">  testproc();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: OK\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 首先从主函数开始，进入testcall函数中，声明struct sysinfo类型的info变量，调用sysinfo系统调用，系统调用返回值保存在info地址中，也就是存在info中，countfree函数用来计算当前空闲内存数，并和info中的freemem属性比对来进行验证，下面的判断没有看懂待学习。之后进入testmem函数来检查空闲内存是否跟踪成功，使用sbrk申请一页，可以得知sbrk其实也是系统调用，调用sysinfo记录空闲内存数，查看当前空闲内存数是否是减去一页的字节数。之后再用sbrk释放一页内存，同样调用sysinfo记录空闲内存数，查看当前空闲内存数是否增加了一页。所以从这里我们可以知道sbrk相当于调用了更为底层的内核函数，这里我们认为是kalloc.c中声明的操作，我们需要做的是在kalloc中找到对释放及申请内存操作的代码，理解清楚，然后才能记录空闲的内存数</p>

<p> testproc是检测进程函数，每次使用fork声明，相当于处于Not Unused状态的进程数加1，使用sysinfotest获取</p>

<p>至此我们已经完全清楚了sysinfotest.c文件中干了什么，这对我们后续书写内核代码非常重要。</p>
<p>下面我们对实验中要求我们学习的代码进行分析：</p>
<h5 id="file-c"><a href="#file-c" class="headerlink" title="file.c"></a>file.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="sysfile-c"><a href="#sysfile-c" class="headerlink" title="sysfile.c"></a>sysfile.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> sys_fstat系统调用用来将所指的文件状态, 复制到参数st所指的结构中。a0寄存器存储文件的描述符，根据描述符返回文件结构体，a1寄存器存储要放的地址，调用filestat实现，调用copyout实现，第一个参数为当前进程的页表，addr为需要存储的用户地址，st是需要存储文件的状态，第三个参数代表st存放的首地址，第四个参数时代表st大小，故从页表对应的内核文件状态首地址读出文件状态，存储到addr代表的用户地址中。</p>

<p>可见无非就是拿到内核中的数据的存放地址，在通过copyout复制到用户addr中</p>

<p>下面具体实现：</p>
<h5 id="kalloc-c"><a href="#kalloc-c" class="headerlink" title="kalloc.c"></a>kalloc.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line">uint64 <span class="title function_">amount_freeMemory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	uint64 n=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">	acquire(&amp;kmem.lock);</span><br><span class="line">	r=kmem.freelist;</span><br><span class="line">	<span class="keyword">while</span>(r)&#123;</span><br><span class="line">            </span><br><span class="line">	    r=r-&gt;next;</span><br><span class="line">	    n=n+PGSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> kmem存储了空闲内存链表freelist,freerange函数是释放从pa_start所指向的地址到pa_end的内存，每次指针移动一页大小，内存按页来释放，每一页的释放又是通过kfree来实现的。现在我们来看看kfree是怎么做到释放一页内存的。</p>

<p> 首先判断当前pa指针，如果还没有释放完一页，则显示panic繁忙信息，之后的两个判断，目前不清楚待学习</p>

<p>memset函数其实是一个填充函数，只对pa为首地址的一页内存全部填1（表明当前此页内存空闲)，最后将pa的地址对应的内存使用头插法挂在空闲内存队首），在挂链表的时候是需要上锁与解锁的，这个在之后会慢慢学习</p>

<p>kalloc函数与kfree相反，从freelist链表首部取出空闲内存，并通过memset函数将5填入进去，表明该地址对应的一页内存是占用状态，返回这个被占用的内存的地址,这其实是申请内存的过程</p>

<p>对于memset的具体实现，交由更为底层的内核代码实现。之后慢慢学习</p>

<p>通过上面的分析，我们得知求取空闲内存数，其实就是对freelist链表进行计数，每一个结点代表一页空闲内存，计数的结果count乘以页大小就是空闲内存大小</p>

<p>这里用amount_freeMemory函数实现,模仿前面的代码进行书写</p>

<p>下面截取了proc.c文件中的部分代码，这部分的代码我还没有掌握好，需要继续学习，以下对我所截取的部分进行分析：</p>
<h5 id="proc-c-1"><a href="#proc-c-1" class="headerlink" title="proc.c"></a>proc.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print a process listing to console.  For debugging.</span></span><br><span class="line"><span class="comment">// Runs when user types ^P on console.</span></span><br><span class="line"><span class="comment">// No lock to avoid wedging a stuck machine further.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">  [UNUSED]    <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">  [SLEEPING]  <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">  [RUNNABLE]  <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">  [RUNNING]   <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">  [ZOMBIE]    <span class="string">&quot;zombie&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">char</span> *state;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])</span><br><span class="line">      state = states[p-&gt;state];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">uint64 <span class="title function_">amount_unusedProcess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">	</span><br><span class="line">	uint64 n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(p=proc;p&lt;&amp;proc[NPROC];p++)</span><br><span class="line">	&#123;    acquire(&amp;p-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;state!=UNUSED)</span><br><span class="line">                 &#123;</span><br><span class="line">			 n=n+<span class="number">1</span>;</span><br><span class="line">		 &#125;	</span><br><span class="line">		release(&amp;p-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> procdump函数其实是将处于使用状态下的进程，输出其进程pid以及状态还有进程名，可以知道进程总数是存在NPROC中，proc其实是进程的数组，每元素是进程结构体。所以如果要求出处于使用状态的进程数，只需对proc数组进行遍历然后计数，这些在amount_unusedProcess函数中实现</p>

<p>至此我们已经能通过amount_freeMemory函数取得空闲内存数，通过amount_unusedProcess函数取得处于非空闲状态的进程数，下面我们就要通过一个函数更新kernel/sysinfo.h文件中的struct sysinfo结构体中的freemen与nproc属性，这里在sysproc.c文件中实现,我们在下面添加这样的函数</p>

<h5 id="sysproc-c-1"><a href="#sysproc-c-1" class="headerlink" title="sysproc.c"></a>sysproc.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">	uint64 st;</span><br><span class="line">	<span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;st)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	info.nproc=amount_unusedProcess();</span><br><span class="line">	info.freemem=amount_freeMemory();</span><br><span class="line">	<span class="keyword">if</span>(copyout(p-&gt;pagetable,st,(<span class="type">char</span>*)&amp;info,<span class="keyword">sizeof</span>(info))&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的函数我们将内存与进程信息存在info中，st中记录了用户空间地址，也就是我们之前sysinfo(info)中info指向的内容，最后通过copyout函数将内核空间下的地址info对应的sizeof(info)大小的数据复制到用户空间下的st地址中，这样我们在用户空间执行之后的代码，info就是我们要用到的进程与内存信息</p>

<p>至此我们完成了从内核空间得到内存与进程信息并返回用户空间的操作，但是make qemu还是会出错，因为我们还需要在user.h声明我们的系统调用函数，以及usys.pl文件中添加存根，另外在syscall.h文件中增加系统调用号，但是make qemu仍出错，那是因为我们在sysproc.c中用到的amount_unusedProcess与amount_freeMemory没有声明，所以要在proc.h文件中加入amount_unusedProcess声明，在新创kalloc.h文件中声明amount_freeMemory，最后将这两个.h文件在sysproc.c中引入，或者我们可以在defs.h文件加入这两个声明</p>

<p>最后编译运行成功</p>

<p><u>掌握的关键点如下：</u></p>
<p><b> 内核是如何传递数据到用户空间，除了lab1中使用寄存器的方式外</b></p>
<p>最后附上运行成功的截图，为醉心研究xv6的各位加油!</p>

<img src="/images/pictures/systemcall/success.PNG" alt="success" style="zoom: 67%;" />



<p>​    </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiaxin Fang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
